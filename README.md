# Fall 2024 Principles of Databases — Assignment 4

* **Do not start this project until you’ve read and understood these instructions. If something is not clear, ask.**

---

## ❖ Introduction ❖

For this assignment, you will write responses to nine questions based on different topics from our textbook, *Database Systems — The Complete Book* and to one question based on your notes. Reply to each question in the provided region using Markdown syntax.

---

## ❖ Questions ❖

### 1. [2.4] What is the difference between a Cartesian Product, a Natural Join, and Theta-Joins?

The primary difference between a cartesian product, natural join, and theta-join is the way tuples from the two relation are paired. The cartesian product will always produce a relation that combines all elements of the first relation with all elements of the second relation. This type of join does not attempt to unify any part of the two relations, or match a component/tuple. As such, a relation produced by a cartesian product will have a number of tuples equal to the number of tuples in the first relation multiplied by the number of tuples in the second relation. The schema for this relation will have a number of attributes equal to the number of attributes in the first relation plus the number of attributes in the second relation. Additionally, any attributes that have the same name in both relations will use dot notation to avoid ambiguity. Conversely, both natural joins and theta-joins attempt pair tuples in two relations that meet a certain condition. For the natural join, two relations are joined on common component values in common attributes between the two relations. As such, for a natural join to work, two relations must have the same name for at least one of their attributes, and at least one of the tuples in each relation must have the same value for that common attribute. For these common attributes, they are present only once in the relation produced by a natural join, and thus avoid dot notation (since the values in both attributes are the same). Theta-joins pair tuples using an arbitrary condition that is defined in the join statement. This means theta-joins are more flexible than natural joins, but are more specific than a cartesian product (typically). Theta-joins also employ dot notation to display attributes that have the same name across two relations, as the arbitrary condition used for the join does not always avoid ambiguity. Additionally, theta-joins have increased flexibility, since the condition given for the join is defined by the query writer (as opposed to being set, like in a natural join). Another important distinction between cartesian product and natural/theta-joins is that natural and theta-joins may have dangling tuples, whereas the cartesian product does not.

### 2. [2.5] What is a Referential Integrity Constraint?

A referential integrity constraint is a type of restriction that can be placed on information stored in a relation. This constraint aims to ensure consistency within a database by connecting two relations. A referential integrity constraint says that a value appearing in a certain context (in this case, a relation) must appear in another related context (relation). Generally, referential integrity constraints are used in two relations that have a logical relationship. For example, suppose two relations exist in database: Employee and Manager. If the Employee relation has an attribute ManagerName (representing the direct overseer of that employee), then intuitively any tuple in Employee must contain a value in ManagerName that exists within the Name attribute of a tuple in Manager. This can be expressed in relational algebra as follows: $\pi_{ManagerName}(Employee) \subseteq \pi_{Name}(Manager)$. This ensures that any value in the ManagerName attribute of any tuple in Employee also exists in the Name attribute of the Manager relation. The referential integrity constraint does not function both ways. As such, there can be additional managers that do not directly supervise an employee. However, it is not possible for an employee to have no manager, as every employee needs a supervisor. Referential integrity constraints are typically placed on a key of the referenced relation. This avoids ambiguity, as otherwise the connection between tuples in the relations would be unclear.

###  3. [2.5] What is a Key Constraint?

A key constraint expresses the concept of uniqueness in a database. For an attribute in a relation, if it is a key, then no two different tuples will have the same value for that key attribute. Typically, key constraints are useful in queries because each key is unique. As such, queries that select using specific key values will always return 1 or 0 tuples. In relational algebra, a key constraint is validated by taking the Cartesian Product of two copies of the same relation and checking if there are any tuples where the key attributes match, but any other attribute does not. If this selection returns the empty set, then the key constraint is maintained. For example, in the Employee(name, jobTitle) relation, a key constraint can be expressed using two renamings of that relation, E1 and E2 as follows. In this example, name is the key. $\sigma_{\text{E1.name = E2.name AND E1.jobTitle = E2.jobTitle}}(E1 \times E2)=\emptyset$. Here, if E1 and E2 match in name, they must also match in jobTitle, meaning they are the same tuple. Any tuples with the same name, but different title would be returned in the select statement, invalidating the constraint.

### 4. [4.1] What is an Entity/Relationship Model? What purpose does it serve in the process of creating/designing databases?

The Entity/Relationship model is way of graphically representing the connections between data in a database. E/R models are comprised of three primary elements: Entity sets, attributes, and relationships. These elements are used to organize the information stored in a database, as well as illustrating connections between entity sets (via relationships), and what information an entity set might contain (via attributes). As a graphical model, entity sets are represented by rectangles, relationships are represented by diamonds, and attributes are represented by ovals. Edges can connect entity sets to each other via relationships, as well as connecting attributes to entity sets and relationships. The E/R model also allows for the illustration of key constraints (via underlines), referential integrity, and cardinality. There are also more complex structures that exist in the E/R model, such as weak entity sets and subclasses. The E/R model is typically used for designing the schema of a database. The model itself does not contain any information, but instead is used to define the high-level structure of the database. As a conceptual model, the E/R diagram has more flexibility than mySQL, which only has relations. Using the wider set of features in the E/R diagram, and then converting to mySQL allows the designer to design an efficient and effective database. Effectively, the E/R model provides a blueprint for a database designer on how to design their database. This allows the designer to optimize their database and ensure that it accurately and efficiently represents the desired information. Many of the core tenets of the E/R model (faithfullness, avoiding redundancy, and simplicity) are also critical in the concrete implementation. If a designer can ensure that these values are maintained during high-level design, it makes their job simpler when it eventually comes to producing the relational database using a language like mySQL.

### 5. [4.4] What is a Weak Entity Set?

A weak entity set is an entity set who's key contains attributes which belong to another entity set. In SQL, this would mean that the weak entity set has a foreign key as part of its primary key. By definition, a weak entity set's key must contain zero or more of its own attributes, and attributes acquired through many-one relationships from that entity set to another entity set (a supporting entity set). For an entity set to be weak, the supporting relationship connecting it to a supporting entity set must be both binary there must be referential integrity from the weak entity set to the supporting entity set. The referenced attribute must be a key attribute in the supporting entity set (this is a common convention for referential integrity, as mentioned above). Weak entity sets are denoted in the E/R model using double-bordered rectangles, with supporting relationships expressed as double-bordered diamonds. In the E/R model, weak entity sets typically arise either in simplifying relationships so that they are binary, or to express hierarchy in cases where "isa hierarchy" does not make sense. For example, an entity set Contract might be a weak entity set supported by Employee, since an employee has a contract (and a contract cannot exist without an employee). The supporting relation connecting the two might be called Contracts-with.

### 6. [5.2.7; 6.3.8] Explain the concepts of Outerjoin, Natural Right Outer Joins, Natural Left Outer Joins, and Full Outer Joins.

An outer join produces the result of a theta-join or natural join (depending on if it is a theta outer join or natural outer join), but includes any dangling tuples in the relation produced. A dangling tuple occurs when a tuple cannot match with another tuple in the other relation. When these dangling tuples are representing in the output of an outer join, any attributes not present in that tuple (but are present in the result of the join) are padded with a null symbol. This facilitates their representation in the resulting relation, while still reflecting the fact that they do not unify with another tuple. Full outer joins completely represent the information stored in the two relations being joined, presenting the dangling tuples from both argument relations. An outer join can be more useful than a natural join or theta join if there is value in assessing which tuples are capable of pairing, as well as which tuples may not pair. Knowing that these dangling tuples exist in a join may be useful for a database designer or in queries, but they would not be shown in a natural join or theta-join. Natural right outer joins are similar to natural outer joins, but only the dangling tuples of the right argument are presented in the output. Conversely, a natural left outer join only includes the dangling tuples of the left argument. In both cases, parts of the output that are not present in the dangling tuple are padded with null. Full joins are the first type of outerjoin described, where all dangling tuples of both argument relations are expressed in the output. In SQL, a full natural outer join would be executed using the following query: SELECT * FROM Table1 NATURAL FULL OUTER JOIN Table2. A full theta outer join is expressed using the following query: SELECT * FROM Table1 FULL OUTER JOIN Table 2 ON condition;. Replacing the prefix "FULL" with "RIGHT" or "LEFT" would produce right and left outer joins respectively.

### 7. [6.6.3] What is the difference between the SQL command `TRANSACTION` and the execution of any statement in SQL?

The primary difference between the TRANSACTION command and the execution of any statement in SQL is that transactions act as safeguards to ensure atomicity and isolation. In addition, transactions can contain numerous SQL statements. The TRANSACTION command allows for the grouping of multiple queries or statements into one atomic unit. This means that all statements within the transaction will either execute or fail. If each statement in a transaction was executed independently, it would be possible to only successfully execute part of the overall transaction, which violates the idea of atomicity. Conversely, transactions will end with either the COMMIT or ROLLBACK statement, which will either permanently install any modifications of the transaction into the database, or revert all changes made by the transaction. These two options mean that it is impossible for a transaction to partially execute. In SQL, transactions can also be given the isolation level of "serializable", which avoids potential problems such as dirty reads. Thus transactions ensure atomicity and can ensure isolation (where applicable), which are important concepts in the design of databases. While individual SQL statements are atomic and isolated, often an operation in a database must be conducted using multiple statements. If a set of SQL statements were used without a transaction, there would be no way to ensure atomicity, as each staatement is its own atomic unit, but the entire operation is composed of many atomic units that can independently succeed or fail. In terms of isolation, with multiple SQL statements not grouped in a transaction, it is possible for an SQL statement not part of this operation to execute between statements, which is a violation of this principle.

### 8. [8] What is a Virtual View and what are its advantages?

A virtual view is a type of SQL relation that does not physically exist, but can still be queried (and occasionally modified). Views are defined using an expression and built from information stored in other relations. The syntax for creating a virtual view is: CREATE VIEW name AS definition;. Generally, views are used for queries, as there are very few cases in which views can be modified. Since views do not store unique data, a modification to a view must alter the physical relation that the view was created from. A view is advantageous as they can be used to simplify future queries. For example, if queries need to often join two tables together to produce an output relation, it may make more sense to create a view that joins the two relation. Then, the view can be queried in the same way as a normal table, and the join statement only needs to be written once (as the view definition). Views can also be used when displaying database content to a user, as they can limit the exposure of the internal structure of the database. For example, certain attributes of a relation might only be used for managing the database (like an ID number), and do not need to be displayed to the user. A view could be employed to ensure that the user does not access data that they should not see. Finally, the attribute names in a created view can be modified from the base tables, which could aid in the presentation of database content.

### 9. [8.3] What is an *index* and what are its advantages?

An index is a type of materialized view to improve the efficiency of queries on a database. An index is placed on an attribute in a relation, and makes it easier to find tuples based on the index attribute. Indices are created using the statement: CREATE INDEX name ON Relation(attribute);. Indices are most useful in relations that have a large number of tuples. Without an index, an SQL query must scan through all tuples to find the tuples that match a condition specified in the SELECT statement. With an index, the query processor can seek conditional matches starting in the middle of the relation, meaning it skips those tuples that it "knows" do not meet the condition. As such, the query processor does not have to retrieve and assess as many pages in memory. Typically, indices are placed on attributes that will be queried often, or on key attributes (or both). Indices have a memory and performance cost, and this cost must be balanced with the potential efficiency improvement that an index can yield. As such, the selection of a good index for a given relation is extremely important. Typically, indexes utilize the B-tree data structure, which yields a time complexity of O(log(n)), whereas a non-indexed SQL query has a time complexity of O(n). Graphically, this supports the fact that indices are generally more valuable on larger tables, as the graph of y = x diverges from y = log(x) as x increases.

### 10. Explain the concept of an MVC, or model, view, controller, framework for designing full stack applications

The MVC framework is used to group different parts of a full stack application. Typically an MVC framework is used for designing applicaations which will accept input from a user. The model is the internal representation of information in the application. This model is independent of the user's interaction with the application, and the user does not have direct access to the model. Often the model can be in the form of relations (as in assignment 3), and is used to organize and store data that is used in the application. If the model is a DBMS, then it is responsible for maintaining ACID and ensuring that data in the application follows the defined rules and logic. The view is the representation of information that is passed to the user, as well as the interface that facilitates user interaction with the model. This aspect of the framework defines the presentation of information stored by the model, and often will allow the user to interact with this data via a graphical interface. The view is also used to separate the user from the model, ensuring that only information that the user should be accessing is presented. The controller serves as the link between the model and view. As such, the view will pass user input to the controller, which will then provide instructions to the model. This means the controller is the only part of the framework that interacts with the model. This maintains security of information in the model, and also allows for the validation of user input. The MVC framework promotes modularity with the implementation of the three parts, which in-turn allows for collaborative work and modification of each part without affecting the others. Each aspect of the framework has a set of defined obligations that generally do not overlap. This promotes security, organization, and effective code practice.

---

## ❖ Due ❖

Sunday, 15 December 2024, at 10:00 AM.

---

## ❖ Grading ❖

| Item        | Points |
|-------------|:------:|
| Question 1  | `10`   |
| Question 2  | `10`   |
| Question 3  | `10`   |
| Question 4  | `10`   |
| Question 5  | `10`   |
| Question 6  | `10`   |
| Question 7  | `10`   |
| Question 8  | `10`   |
| Question 9  | `10`   |
| Question 10 | `10`   |

---

## ❖ Submission ❖

**NO late submissions will be accepted.**

You will need to issue a pull request back into the original repo, the one from which your fork was created for this project. See the **Issuing Pull Requests** section of [this site](http://code-warrior.github.io/tutorials/git/github/index.html) for help on how to submit your assignment.

**Note**: This assignment may **only** be submitted via GitHub. **No other form of submission will be accepted**.
